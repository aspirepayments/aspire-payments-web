// Prisma schema (minimal MVP)
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  
}

model Merchant {
  id                 String               @id @default(cuid())
  name               String
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  // TODO: add gateway configs, settlement prefs
  payments           Payment[]
  gateways           MerchantGateway[]
  Customer           Customer[]
  Invoice            Invoice[]
  Item               Item[]
  MerchantProfile    MerchantProfile?
  FeeConfig          FeeConfig?
  User               User[]
  FeePlan            FeePlan[]
  TaxRate            TaxRate[]
  StraddleConnection StraddleConnection[]
  straddleAccountId  String?              @unique
  PaymentTerm        PaymentTerm[]
}

model Payment {
  id             String           @id @default(cuid())
  merchantId     String
  merchant       Merchant         @relation(fields: [merchantId], references: [id])
  amount         Int
  currency       String           @default("USD")
  method         String // "card" | "bank"
  rail           String? // "ach" | "rtp_rfp" | "fednow"
  provider       String // "nmi" | "authorize_net" | "straddle" | ...
  status         String // "created" | "authorized" | "captured" | "settled" | "returned" | "refunded" | "voided" | "failed" | "pending"
  providerRef    String? // NEW: Straddle transfer id or NMI tx id
  instrumentMask String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  attempts       PaymentAttempt[]
  refunds        Refund[]
  postedAt       DateTime? // when charge is posted
  settledAt      DateTime? // when charge is settled
  returnCode     String? // ACH/NACHA return code, if any
  returnReason   String? // provider return reason text
  lastEventAt    DateTime? // timestamp of the last lifecycle event we processed

  @@index([merchantId])
}

model PaymentAttempt {
  id             String   @id @default(cuid())
  paymentId      String
  payment        Payment  @relation(fields: [paymentId], references: [id])
  idempotencyKey String?
  providerRef    String?
  requestJson    Json?
  responseJson   Json?
  status         String
  createdAt      DateTime @default(now())
}

model Refund {
  id          String   @id @default(cuid())
  paymentId   String
  payment     Payment  @relation(fields: [paymentId], references: [id])
  amount      Int
  status      String
  providerRef String?
  createdAt   DateTime @default(now())
}

model WebhookEvent {
  id          String    @id @default(cuid())
  provider    String
  eventType   String
  externalId  String
  payloadHash String
  processed   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@unique([provider, externalId])
}

model Idempotency {
  key          String   @id
  createdAt    DateTime @default(now())
  responseJson Json?
}

model MerchantGateway {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])
  type       String // 'nmi' (future: 'authorize_net', etc.)
  apiKey     String // NMI security_key
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // compound unique so we can do where: { merchantId_type: { ... } }
  @@unique([merchantId, type])
}

/// === Customers & Invoices ===

model Customer {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])
  firstName  String
  lastName   String
  company    String?
  email      String?
  phone      String?
  address1   String?
  address2   String?
  city       String?
  state      String?
  postal     String?
  country    String?  @default("US")
  terms      String? // e.g., "Net 30"
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  invoices      Invoice[]
  PaymentMethod PaymentMethod[]
}

model Invoice {
  id           String   @id @default(cuid())
  merchantId   String
  merchant     Merchant @relation(fields: [merchantId], references: [id])
  customerId   String
  customer     Customer @relation(fields: [customerId], references: [id])
  number       String   @unique
  status       String // "draft" | "open" | "paid" | "void" | "overdue" | "partial"
  issueDate    DateTime
  dueDate      DateTime
  currency     String   @default("USD")
  subtotal     Int // cents
  taxRateId    String?
  taxTotal     Int      @default(0)
  total        Int // cents
  amountPaid   Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  term         String?
  message      String?
  internalNote String?

  items InvoiceItem[]
}

model InvoiceItem {
  id          String  @id @default(cuid())
  invoiceId   String
  invoice     Invoice @relation(fields: [invoiceId], references: [id])
  itemId      String? // optional link to catalog item
  item        Item?   @relation(fields: [itemId], references: [id])
  description String
  quantity    Int
  unitPrice   Int // cents
  amount      Int // quantity*unitPrice; stored for reporting
  taxable     Boolean @default(false)
}

model Item {
  id          String   @id @default(cuid())
  merchantId  String
  merchant    Merchant @relation(fields: [merchantId], references: [id])
  name        String
  description String?
  unitPrice   Int // default unit price in cents
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  invoiceItems InvoiceItem[]
}

/// === Settings: Merchant Profile ===
model MerchantProfile {
  id         String   @id @default(cuid())
  merchantId String   @unique
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  companyName String?
  address1    String?
  address2    String?
  city        String?
  state       String?
  postal      String?
  country     String? @default("US")

  phone      String?
  websiteUrl String?
  email      String?
  taxId      String?
  logoUrl    String? // URL for now; later: file upload

  termsText         String? // “custom import”
  refundPolicyText  String?
  privacyPolicyText String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// === Settings: Fees ===
model FeeConfig {
  id         String   @id @default(cuid())
  merchantId String   @unique
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  mode                String @default("none") // "none" | "convenience" | "service"
  convenienceFeeCents Int    @default(0)
  serviceFeeBps       Int    @default(0) // e.g., 250 = 2.50%

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// === Users (very simple; no auth yet) ===
model User {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  firstName String
  lastName  String
  email     String   @unique
  mobile    String?
  role      String   @default("admin") // only "admin" for now
  passwordHash String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// === Settings: multiple Fee Plans ===
model FeePlan {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  name                String
  mode                String @default("none") // "none" | "convenience" | "service"
  convenienceFeeCents Int    @default(0)
  serviceFeeBps       Int    @default(0) // e.g., 250 = 2.50%

  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// === Settings: Sales Tax Rates ===
model TaxRate {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])
  name       String
  rateBps    Int // basis points, e.g., 650 = 6.50%
  isDefault  Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

/// === Saved Payment Methods (Vault) ===
/// Use ONE table for both cards and Straddle pay-by-bank.
/// For Straddle pay-by-bank: type='bank', vaultProvider='straddle', providerRef=<paykey>
model PaymentMethod {
  id         String   @id @default(cuid())
  merchantId String
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])

  type          String // 'card' | 'bank'
  vaultProvider String // 'nmi' | 'straddle' | 'authorize_net' | 'plaid' | 'spreedly'
  providerRef   String // e.g., NMI customer_vault_id or Straddle paykey
  brand         String? // 'visa', 'mc', 'amex', 'ach'
  last4         String?
  expMonth      Int?
  expYear       Int?
  bankName      String?
  mask          String? // e.g., ****6789

  isDefault Boolean  @default(false)
  status    String   @default("active") // 'active' | 'inactive'
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([customerId, vaultProvider, providerRef])
  @@index([customerId])
}

/// === Straddle connection (per merchant or org-level) ===
/// Keep exactly one row per merchant per environment.
model StraddleConnection {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  environment String // 'sandbox' | 'production'
  apiKey      String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([merchantId, environment])
  @@index([merchantId])
}

model CustomerExternal {
  id         String   @id @default(cuid())
  customerId String
  provider   String // e.g., 'straddle'
  externalId String // e.g., straddle customer id
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([provider, externalId])
  @@index([customerId])
}

model PaymentTerm {
  id         String   @id @default(cuid())
  merchantId String
  merchant   Merchant @relation(fields: [merchantId], references: [id])

  name      String // e.g., "Net 30", "Due on Receipt"
  days      Int // number of days from issue
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([merchantId])
}
